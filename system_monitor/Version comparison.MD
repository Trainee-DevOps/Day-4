# System Monitor - Version Comparison

This document provides a detailed comparison between the **OLD** and **NEW** versions of the system monitor, highlighting improvements, new features, and key differences.

---

## ğŸ“Š High-Level Summary

| Aspect | Old Version | New Version | Improvement |
|--------|-------------|-------------|-------------|
| **Lines of Code** | ~100 lines | ~600+ lines | 6x more comprehensive |
| **Safety Features** | None | 6 major features | Critical improvement |
| **Configuration Options** | 3 settings | 9 settings | 3x more configurable |
| **Error Handling** | Minimal | Extensive | Production-ready |
| **User Interface** | Basic text | Rich ASCII + colors | Professional look |
| **Process Killing** | Immediate SIGKILL | Graceful + protection | Much safer |
| **Logging** | Basic warnings | Detailed event logging | Better debugging |
| **Network Detection** | Hardcoded patterns | Auto-detection | More reliable |

---

## ğŸ”§ Configuration File Comparison

### OLD: `monitor_config.conf`

```properties
CPU_THRESHOLD=80
MEM_THRESHOLD=85
DISK_THRESHOLD=90
```

**Limitations:**
- Only 3 basic thresholds
- No control over automated actions
- No process protection
- No customization of behavior

---

### NEW: `monitor_config.conf`

```properties
# Resource Thresholds
CPU_THRESHOLD=80
MEM_THRESHOLD=85
DISK_THRESHOLD=90

# Auto-Kill Configuration
AUTO_KILL_ENABLED=false
CPU_KILL_THRESHOLD=95
MEM_KILL_THRESHOLD=95

# Protected Processes
PROTECTED_PROCESSES="systemd init bash sshd ssh docker dockerd kubelet kube mysql postgres nginx apache2 httpd"

# Monitoring Settings
INTERVAL=5
KILL_COOLDOWN=60
```

**Improvements:**
- âœ… **Dual threshold system** (alert vs. action)
- âœ… **Kill safety toggle** (AUTO_KILL_ENABLED)
- âœ… **Protected process list** (prevents critical system damage)
- âœ… **Configurable timing** (INTERVAL, KILL_COOLDOWN)
- âœ… **Separate kill thresholds** (more granular control)

---

## ğŸ“ Script Comparison

### 1. **Initialization & Configuration**

#### OLD Version
```bash
CONFIG_FILE="./monitor_config.conf"
LOG_FILE="./monitor.log"
CSV_FILE="./system_metrics.csv"
INTERVAL=5

# Load config
source "$CONFIG_FILE"
```

**Issues:**
- âŒ No error checking if config file missing
- âŒ Hard-coded file paths
- âŒ No environment variable support

---

#### NEW Version
```bash
CONFIG_FILE="${CONFIG_FILE:-./monitor_config.conf}"
LOG_FILE="${LOG_FILE:-./monitor.log}"
CSV_FILE="${CSV_FILE:-./system_metrics.csv}"
INTERVAL=${INTERVAL:-5}

# Colors for dashboard
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

# Load config if exists
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
else
    # Defaults
    CPU_THRESHOLD=80
    MEM_THRESHOLD=85
    DISK_THRESHOLD=90
    AUTO_KILL_ENABLED=false
    PROTECTED_PROCESSES="systemd init bash sshd"
fi
```

**Improvements:**
- âœ… **Environment variable override** (flexible deployment)
- âœ… **Safe config loading** (checks if file exists)
- âœ… **Fallback defaults** (works without config file)
- âœ… **Color definitions** (better UI)
- âœ… **Better error resilience**

---

### 2. **CSV Initialization**

#### OLD Version
```bash
if [[ ! -f "$CSV_FILE" ]]; then
    echo "Timestamp,CPU_Usage(%),Memory_Usage(%),Disk_Usage(%),RX_KB/s,TX_KB/s" > "$CSV_FILE"
fi
```

**Issues:**
- âŒ Missing top process columns
- âŒ Limited data for analysis

---

#### NEW Version
```bash
if [[ ! -f "$CSV_FILE" ]]; then
    echo "Timestamp,CPU_Usage(%),Memory_Usage(%),Disk_Usage(%),RX_KB/s,TX_KB/s,Top_Process,Top_Process_CPU" > "$CSV_FILE"
fi
```

**Improvements:**
- âœ… **Process tracking** (identifies resource hogs)
- âœ… **Better historical analysis** (can see trends)

---

### 3. **Logging Function**

#### OLD Version
```bash
# No dedicated logging function
# Logging done inline: echo "$(date) WARNING: ..." >> "$LOG_FILE"
```

**Issues:**
- âŒ Inconsistent log format
- âŒ No log levels
- âŒ Repetitive code

---

#### NEW Version
```bash
log_message() {
    local level=$1
    local message=$2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $message" >> "$LOG_FILE"
}
```

**Improvements:**
- âœ… **Consistent format** (timestamp [LEVEL] message)
- âœ… **Log levels** (INFO, WARN, ERROR, ACTION, ALERT)
- âœ… **Reusable function** (DRY principle)
- âœ… **Better parsing** (structured logs)

---

### 4. **CPU Monitoring**

#### OLD Version
```bash
get_cpu() {
    top -bn1 | awk '/Cpu/ {print 100 - $8}'
}
```

**Issues:**
- âŒ **Single snapshot** (inaccurate for spiky loads)
- âŒ Returns float with decimals
- âŒ No error handling

---

#### NEW Version
```bash
get_cpu() {
    # More reliable CPU calculation
    top -bn2 -d 0.5 | grep "Cpu(s)" | tail -1 | awk '{print 100 - $8}' | cut -d'.' -f1
}
```

**Improvements:**
- âœ… **Two snapshots** (`-bn2 -d 0.5`) = more accurate average
- âœ… **Integer output** (easier threshold comparison)
- âœ… **Filtered output** (`grep "Cpu(s)"` more precise)
- âœ… **Last measurement** (`tail -1` gets settled value)

**Technical Detail:**
```
Old: top -bn1           â†’ Single instant snapshot
New: top -bn2 -d 0.5    â†’ Two samples 0.5s apart, use 2nd

Why better?
- First reading often inaccurate (initialization)
- Second reading is settled/stable
- Averages out microsecond spikes
```

---

### 5. **Memory Monitoring**

#### OLD Version
```bash
get_memory() {
    free | awk '/Mem/ {printf "%.2f", $3/$2 * 100}'
}
```

**Output:** `67.25` (2 decimals)

---

#### NEW Version
```bash
get_memory() {
    free | awk '/Mem/ {printf "%.1f", ($3/$2) * 100}'
}
```

**Output:** `67.3` (1 decimal)

**Changes:**
- âœ… **Cleaner output** (1 decimal sufficient)
- âœ… **Explicit parentheses** (clearer calculation)

---

### 6. **Network Monitoring**

#### OLD Version
```bash
get_network() {
    RX1=$(cat /proc/net/dev | awk '/eth|ens|enp/ {rx+=$2} END {print rx}')
    TX1=$(cat /proc/net/dev | awk '/eth|ens|enp/ {tx+=$10} END {print tx}')
    sleep 1
    RX2=$(cat /proc/net/dev | awk '/eth|ens|enp/ {rx+=$2} END {print rx}')
    TX2=$(cat /proc/net/dev | awk '/eth|ens|enp/ {tx+=$10} END {print tx}')

    RX_RATE=$(( (RX2 - RX1) / 1024 ))
    TX_RATE=$(( (TX2 - TX1) / 1024 ))

    echo "$RX_RATE $TX_RATE"
}
```

**Issues:**
- âŒ **Hardcoded patterns** (`eth|ens|enp`) - won't work on all systems
- âŒ **Aggregates all interfaces** (can't isolate primary)
- âŒ **No fallback** if pattern doesn't match
- âŒ **No error handling** for missing files

---

#### NEW Version
```bash
get_network() {
    local interface=$(ip route | grep default | awk '{print $5}' | head -1)
    
    if [[ -z "$interface" ]]; then
        # Fallback to first active interface
        interface=$(ls /sys/class/net/ | grep -v lo | head -1)
    fi
    
    if [[ -z "$interface" ]] || [[ ! -d "/sys/class/net/$interface" ]]; then
        echo "0 0"
        return
    fi
    
    local RX1=$(cat /sys/class/net/$interface/statistics/rx_bytes 2>/dev/null || echo 0)
    local TX1=$(cat /sys/class/net/$interface/statistics/tx_bytes 2>/dev/null || echo 0)
    
    sleep 1
    
    local RX2=$(cat /sys/class/net/$interface/statistics/rx_bytes 2>/dev/null || echo 0)
    local TX2=$(cat /sys/class/net/$interface/statistics/tx_bytes 2>/dev/null || echo 0)
    
    local RX_RATE=$(( (RX2 - RX1) / 1024 ))
    local TX_RATE=$(( (TX2 - TX1) / 1024 ))
    
    echo "$RX_RATE $TX_RATE"
}
```

**Improvements:**
- âœ… **Auto-detects default interface** (uses routing table)
- âœ… **Fallback mechanism** (tries alternative if default fails)
- âœ… **Error handling** (returns "0 0" if all fails)
- âœ… **Uses sysfs** (more reliable than /proc/net/dev)
- âœ… **Suppresses errors** (`2>/dev/null`)
- âœ… **Works on any Linux system** (no hardcoded names)

**Technical Detail:**
```
Old Approach:
/proc/net/dev â†’ Parse all eth*/ens*/enp* â†’ Sum values
Problem: What if interface is wlan0, wlp3s0, or something else?

New Approach:
1. ip route â†’ Find default gateway interface
2. If empty â†’ List /sys/class/net/ â†’ Pick first non-loopback
3. Read from /sys/class/net/INTERFACE/statistics/
4. If any step fails â†’ Return "0 0" gracefully

Result: Works on Ubuntu, Debian, CentOS, Arch, etc.
```

---

### 7. **Process Listing**

#### OLD Version
```bash
top_processes() {
    ps -eo pid,comm,%cpu,%mem --sort=-%cpu | head -n 11
}
```

---

#### NEW Version
```bash
top_processes() {
    ps -eo pid,user,comm,%cpu,%mem --sort=-%cpu | head -n 11
}
```

**Improvement:**
- âœ… **Added USER column** (know who owns resource hogs)
- âœ… **Better security auditing** (identify unauthorized processes)

---

### 8. **Process Killing - THE BIGGEST CHANGE**

#### OLD Version
```bash
take_action() {
    local TYPE=$1
    local VALUE=$2

    echo "$(date) WARNING: $TYPE usage high ($VALUE%)" >> "$LOG_FILE"

    # Kill highest CPU consumer if CPU critical
    if [[ "$TYPE" == "CPU" ]]; then
        PID=$(ps -eo pid,%cpu --sort=-%cpu | awk 'NR==2 {print $1}')
        echo "$(date) ACTION: Killing process PID=$PID" >> "$LOG_FILE"
        kill -9 "$PID"
    fi
}
```

**CRITICAL ISSUES:**
- âŒ **Immediate SIGKILL (-9)** - no graceful shutdown
- âŒ **No process verification** - might not exist
- âŒ **No protection** - could kill systemd, sshd, etc.
- âŒ **No cooldown** - could kill same PID repeatedly
- âŒ **Kills on ANY threshold** - even at 80%
- âŒ **No process info logging** - can't tell what was killed
- âŒ **No error handling** - silent failures

**DANGER EXAMPLE:**
```bash
# Scenario: SSH daemon temporarily spikes to 81% CPU
# Old version:
1. Detect CPU > 80%
2. Find top process (sshd)
3. kill -9 sshd
4. YOU'RE LOCKED OUT OF YOUR SERVER!
```

---

#### NEW Version - Safety Functions

##### **1. Protected Process Check**
```bash
is_protected_process() {
    local pid=$1
    local cmd=$(ps -p "$pid" -o comm= 2>/dev/null)
    
    if [[ -z "$cmd" ]]; then
        return 1  # Process doesn't exist
    fi
    
    # Check if process is in protected list
    for protected in $PROTECTED_PROCESSES; do
        if [[ "$cmd" == *"$protected"* ]]; then
            return 0  # Protected
        fi
    done
    
    return 1  # Not protected
}
```

**Safety Feature:**
- Prevents killing critical system processes
- Checks against configurable list
- Returns status code (0=protected, 1=safe to kill)

---

##### **2. Kill Cooldown Tracking**
```bash
KILLED_PIDS=()
KILL_COOLDOWN=60

was_recently_killed() {
    local pid=$1
    local now=$(date +%s)
    
    # Clean up old entries from killed list
    local new_killed=()
    for entry in "${KILLED_PIDS[@]}"; do
        local killed_pid=$(echo "$entry" | cut -d':' -f1)
        local killed_time=$(echo "$entry" | cut -d':' -f2)
        
        if (( now - killed_time < KILL_COOLDOWN )); then
            new_killed+=("$entry")
        fi
    done
    KILLED_PIDS=("${new_killed[@]}")
    
    # Check if PID was recently killed
    for entry in "${KILLED_PIDS[@]}"; do
        local killed_pid=$(echo "$entry" | cut -d':' -f1)
        if [[ "$killed_pid" == "$pid" ]]; then
            return 0  # Recently killed
        fi
    done
    
    return 1  # Not recently killed
}
```

**Safety Feature:**
- Prevents rapid re-killing of restarting processes
- 60-second cooldown window
- Auto-cleans old entries
- Prevents kill loops

---

##### **3. Graceful Kill with Fallback**
```bash
safe_kill_process() {
    local pid=$1
    local reason=$2
    
    # Verify process still exists
    if ! ps -p "$pid" > /dev/null 2>&1; then
        log_message "WARN" "Process PID=$pid no longer exists, skipping kill"
        return 1
    fi
    
    # Check if protected
    if is_protected_process "$pid"; then
        local cmd=$(ps -p "$pid" -o comm=)
        log_message "WARN" "Process PID=$pid ($cmd) is protected, skipping kill"
        return 1
    fi
    
    # Check if recently killed
    if was_recently_killed "$pid"; then
        log_message "WARN" "Process PID=$pid was recently killed, skipping (cooldown active)"
        return 1
    fi
    
    # Get process info before killing
    local proc_info=$(ps -p "$pid" -o user=,comm=,%cpu=,%mem= 2>/dev/null)
    
    if [[ -z "$proc_info" ]]; then
        log_message "WARN" "Cannot get info for PID=$pid, process may have exited"
        return 1
    fi
    
    log_message "ACTION" "Killing process: PID=$pid, Info: $proc_info, Reason: $reason"
    
    # Try graceful kill first (SIGTERM)
    kill -15 "$pid" 2>/dev/null
    
    # Wait 2 seconds for graceful shutdown
    sleep 2
    
    # Check if still running
    if ps -p "$pid" > /dev/null 2>&1; then
        log_message "ACTION" "Process PID=$pid still running, sending SIGKILL"
        kill -9 "$pid" 2>/dev/null
        
        if [[ $? -eq 0 ]]; then
            log_message "ACTION" "Successfully force-killed PID=$pid"
        else
            log_message "ERROR" "Failed to kill PID=$pid: $?"
            return 1
        fi
    else
        log_message "ACTION" "Process PID=$pid terminated gracefully"
    fi
    
    # Add to recently killed list
    KILLED_PIDS+=("$pid:$(date +%s)")
    
    return 0
}
```

**Safety Features:**
1. âœ… Verifies process exists
2. âœ… Checks protection list
3. âœ… Checks cooldown
4. âœ… Logs detailed info
5. âœ… SIGTERM first (graceful)
6. âœ… Waits 2 seconds
7. âœ… SIGKILL only if needed
8. âœ… Tracks in cooldown list

---

##### **4. Smart Action Handler**
```bash
take_action() {
    local TYPE=$1
    local VALUE=$2
    
    log_message "ALERT" "$TYPE usage high (${VALUE}%)"
    
    # Only auto-kill if enabled in config
    if [[ "${AUTO_KILL_ENABLED:-false}" != "true" ]]; then
        log_message "INFO" "Auto-kill disabled, manual intervention required"
        return
    fi
    
    # Kill highest CPU consumer if CPU critical
    if [[ "$TYPE" == "CPU" ]] && (( VALUE >= ${CPU_KILL_THRESHOLD:-95} )); then
        local hog_info=$(get_top_resource_hog)
        
        if [[ -z "$hog_info" ]]; then
            log_message "WARN" "No suitable process found to kill"
            return
        fi
        
        local pid=$(echo "$hog_info" | cut -d'|' -f1)
        local cmd=$(echo "$hog_info" | cut -d'|' -f2)
        local cpu=$(echo "$hog_info" | cut -d'|' -f3)
        
        log_message "WARN" "Top CPU consumer: PID=$pid CMD=$cmd CPU=${cpu}%"
        
        # Only kill if process is using significant CPU
        if (( $(echo "$cpu > 50" | bc -l) )); then
            safe_kill_process "$pid" "High CPU usage (${cpu}%)"
        else
            log_message "INFO" "Top process CPU usage (${cpu}%) below kill threshold"
        fi
    fi
    
    # Handle high memory
    if [[ "$TYPE" == "MEMORY" ]] && (( VALUE >= ${MEM_KILL_THRESHOLD:-95} )); then
        # Similar logic for memory...
    fi
}
```

**Improvements:**
- âœ… **Manual mode by default** (AUTO_KILL_ENABLED=false)
- âœ… **Dual threshold** (alert at 80%, kill at 95%)
- âœ… **Usage verification** (must use >50% CPU to kill)
- âœ… **Memory handling** (separate logic)
- âœ… **Detailed logging** at every step

---

### 9. **Dashboard UI**

#### OLD Version
```bash
dashboard() {
    while true; do
        clear
        CPU=$(get_cpu)
        MEM=$(get_memory)
        DISK=$(get_disk)
        read RX TX <<< $(get_network)

        echo "================= SYSTEM MONITOR DASHBOARD ================="
        echo "Time      : $(date)"
        echo "------------------------------------------------------------"
        printf "CPU Usage : %.2f%%\n" "$CPU"
        printf "Memory    : %.2f%%\n" "$MEM"
        printf "Disk      : %s%%\n" "$DISK"
        echo "Network   : RX ${RX}KB/s | TX ${TX}KB/s"
        echo "------------------------------------------------------------"
        echo "Top 10 Resource Consuming Processes"
        echo "PID     COMMAND        CPU%   MEM%"
        top_processes
        echo "============================================================"

        sleep "$INTERVAL"
    done
}
```

**Output Example:**
```
================= SYSTEM MONITOR DASHBOARD =================
Time      : Tue Feb  4 14:30:15 UTC 2025
------------------------------------------------------------
CPU Usage : 45.00%
Memory    : 67.25%
Disk      : 82%
Network   : RX 1523KB/s | TX 842KB/s
------------------------------------------------------------
Top 10 Resource Consuming Processes
PID     COMMAND        CPU%   MEM%
5678    chrome         45.2   12.3
9012    python         23.1   8.5
============================================================
```

**Issues:**
- âŒ Plain text (no colors)
- âŒ No visual bars
- âŒ No status indicators
- âŒ No color-coded warnings
- âŒ Basic formatting

---

#### NEW Version
```bash
dashboard() {
    echo "Starting dashboard mode (Ctrl+C to exit)..."
    sleep 2
    
    while true; do
        clear
        
        CPU=$(get_cpu)
        MEM=$(get_memory)
        DISK=$(get_disk)
        read RX TX <<< $(get_network)
        
        # Determine colors
        local cpu_color=$GREEN
        (( CPU > CPU_THRESHOLD )) && cpu_color=$RED
        (( CPU > CPU_THRESHOLD * 7 / 10 )) && (( CPU <= CPU_THRESHOLD )) && cpu_color=$YELLOW
        
        local mem_color=$GREEN
        (( $(echo "$MEM > $MEM_THRESHOLD" | bc -l) )) && mem_color=$RED
        (( $(echo "$MEM > $MEM_THRESHOLD * 0.7" | bc -l) )) && (( $(echo "$MEM <= $MEM_THRESHOLD" | bc -l) )) && mem_color=$YELLOW
        
        local disk_color=$GREEN
        (( DISK > DISK_THRESHOLD )) && disk_color=$RED
        (( DISK > DISK_THRESHOLD * 7 / 10 )) && (( DISK <= DISK_THRESHOLD )) && disk_color=$YELLOW
        
        # Header
        echo -e "${BOLD}${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
        echo -e "${BOLD}${CYAN}â•‘                      SYSTEM RESOURCE MONITOR - DASHBOARD                     â•‘${NC}"
        echo -e "${BOLD}${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo ""
        echo -e "${BOLD}${BLUE}ğŸ“… Time:${NC} $(date '+%Y-%m-%d %H:%M:%S')"
        echo -e "${BOLD}${BLUE}ğŸ”„ Interval:${NC} ${INTERVAL}s | ${BOLD}${BLUE}Auto-Kill:${NC} ${AUTO_KILL_ENABLED:-false}"
        echo ""
        
        # System Metrics
        echo -e "${BOLD}${MAGENTA}â”Œâ”€ SYSTEM METRICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        echo ""
        
        # CPU
        echo -e "${BOLD}  ğŸ–¥ï¸  CPU Usage:${NC} ${cpu_color}${BOLD}${CPU}%${NC} (threshold: ${CPU_THRESHOLD}%)"
        echo -n "     "
        draw_bar "$CPU" 100 "$cpu_color"
        echo ""
        echo ""
        
        # Memory
        echo -e "${BOLD}  ğŸ’¾ Memory Usage:${NC} ${mem_color}${BOLD}${MEM}%${NC} (threshold: ${MEM_THRESHOLD}%)"
        echo -n "     "
        draw_bar "$MEM" 100 "$mem_color"
        echo ""
        echo ""
        
        # Disk
        echo -e "${BOLD}  ğŸ’¿ Disk Usage:${NC} ${disk_color}${BOLD}${DISK}%${NC} (threshold: ${DISK_THRESHOLD}%)"
        echo -n "     "
        draw_bar "$DISK" 100 "$disk_color"
        echo ""
        echo ""
        
        # Network
        echo -e "${BOLD}  ğŸŒ Network:${NC}"
        echo -e "     ${BOLD}â†“ RX:${NC} ${GREEN}${RX}${NC} KB/s"
        echo -e "     ${BOLD}â†‘ TX:${NC} ${YELLOW}${TX}${NC} KB/s"
        echo ""
        
        echo -e "${BOLD}${MAGENTA}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        echo ""
        
        # Top 10 Processes with color coding
        echo -e "${BOLD}${MAGENTA}â”Œâ”€ TOP 10 RESOURCE-CONSUMING PROCESSES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        echo ""
        printf "${BOLD}%-8s %-10s %-15s %-8s %-8s${NC}\n" "PID" "USER" "COMMAND" "CPU%" "MEM%"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        top_processes | tail -n +2 | while read line; do
            local pid=$(echo "$line" | awk '{print $1}')
            local user=$(echo "$line" | awk '{print $2}')
            local cmd=$(echo "$line" | awk '{print $3}')
            local cpu=$(echo "$line" | awk '{print $4}')
            local mem=$(echo "$line" | awk '{print $5}')
            
            # Color code high CPU
            local proc_color=$NC
            (( $(echo "$cpu > 50" | bc -l) )) && proc_color=$RED
            (( $(echo "$cpu > 20 && $cpu <= 50" | bc -l) )) && proc_color=$YELLOW
            
            printf "${proc_color}%-8s %-10s %-15s %-8s %-8s${NC}\n" "$pid" "$user" "$cmd" "$cpu" "$mem"
        done
        
        echo -e "${BOLD}${MAGENTA}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        echo ""
        
        # Status
        echo -e "${BOLD}${BLUE}Status:${NC}"
        local alerts=0
        (( CPU > CPU_THRESHOLD )) && { echo -e "  ${RED}âš ${NC}  CPU usage is high (${CPU}%)"; ((alerts++)); }
        (( $(echo "$MEM > $MEM_THRESHOLD" | bc -l) )) && { echo -e "  ${RED}âš ${NC}  Memory usage is high (${MEM}%)"; ((alerts++)); }
        (( DISK > DISK_THRESHOLD )) && { echo -e "  ${RED}âš ${NC}  Disk usage is high (${DISK}%)"; ((alerts++)); }
        
        if [[ $alerts -eq 0 ]]; then
            echo -e "  ${GREEN}âœ“${NC} All metrics within normal range"
        fi
        
        echo ""
        echo -e "${CYAN}Press Ctrl+C to exit dashboard${NC}"
        
        sleep "$INTERVAL"
    done
}
```

**NEW Features:**
- âœ… **Color-coded metrics** (Green/Yellow/Red based on thresholds)
- âœ… **Progress bars** (visual representation)
- âœ… **Unicode box drawing** (professional look)
- âœ… **Emoji icons** (ğŸ–¥ï¸ ğŸ’¾ ğŸ’¿ ğŸŒ)
- âœ… **Dynamic colors** for processes (high CPU = red)
- âœ… **Status summary** (alerts count)
- âœ… **Threshold display** (shows limits)
- âœ… **Startup message** (better UX)

**NEW Visual Example:**
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                      SYSTEM RESOURCE MONITOR - DASHBOARD                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“… Time: 2025-02-04 14:30:15
ğŸ”„ Interval: 5s | Auto-Kill: false

â”Œâ”€ SYSTEM METRICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”

  ğŸ–¥ï¸  CPU Usage: 45% (threshold: 80%)
     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]

  ğŸ’¾ Memory Usage: 67.3% (threshold: 85%)
     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]

  ğŸ’¿ Disk Usage: 82% (threshold: 90%)
     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]

  ğŸŒ Network:
     â†“ RX: 1523 KB/s
     â†‘ TX: 842 KB/s

â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ TOP 10 RESOURCE-CONSUMING PROCESSES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”

PID      USER       COMMAND         CPU%     MEM%    
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5678     user       chrome          45.2     12.3    
9012     user       python          23.1     8.5     

â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Status:
  âœ“ All metrics within normal range

Press Ctrl+C to exit dashboard
```

---

### 10. **Progress Bar Function** (NEW ONLY)

```bash
draw_bar() {
    local value=$1
    local max=${2:-100}
    local width=40
    local color=$3
    
    local filled=$(awk "BEGIN {printf \"%.0f\", ($value/$max)*$width}")
    local empty=$((width - filled))
    
    echo -n "["
    if [[ -n "$color" ]]; then
        echo -n -e "$color"
    fi
    
    for ((i=0; i<filled; i++)); do echo -n "â–ˆ"; done
    
    if [[ -n "$color" ]]; then
        echo -n -e "$NC"
    fi
    
    for ((i=0; i<empty; i++)); do echo -n "â–‘"; done
    echo -n "]"
}
```

**Features:**
- Creates visual progress bars
- Supports custom colors
- Filled blocks (â–ˆ) and empty blocks (â–‘)
- Configurable width (default 40 chars)

---

### 11. **Daemon Mode**

#### OLD Version
```bash
daemon() {
    while true; do
        CPU=$(get_cpu)
        MEM=$(get_memory)
        DISK=$(get_disk)
        read RX TX <<< $(get_network)

        echo "$(date),$CPU,$MEM,$DISK,$RX,$TX" >> "$CSV_FILE"

        (( $(echo "$CPU > $CPU_THRESHOLD" | bc -l) )) && take_action "CPU" "$CPU"
        (( $(echo "$MEM > $MEM_THRESHOLD" | bc -l) )) && take_action "MEMORY" "$MEM"
        (( DISK > DISK_THRESHOLD )) && take_action "DISK" "$DISK"

        sleep "$INTERVAL"
    done
}
```

**Issues:**
- âŒ No startup message
- âŒ Missing top process tracking in CSV
- âŒ Kills immediately on threshold

---

#### NEW Version
```bash
daemon() {
    log_message "INFO" "Starting system monitor daemon (PID: $$)"
    echo "Daemon mode started. Check $LOG_FILE for alerts."
    
    while true; do
        CPU=$(get_cpu)
        MEM=$(get_memory)
        DISK=$(get_disk)
        read RX TX <<< $(get_network)
        
        # Get top process info
        local top_proc=$(get_top_resource_hog)
        local top_proc_name=$(echo "$top_proc" | cut -d'|' -f2)
        local top_proc_cpu=$(echo "$top_proc" | cut -d'|' -f3)
        
        # Record to CSV
        echo "$(date '+%Y-%m-%d %H:%M:%S'),$CPU,$MEM,$DISK,$RX,$TX,$top_proc_name,$top_proc_cpu" >> "$CSV_FILE"
        
        # Check thresholds
        (( CPU > CPU_THRESHOLD )) && take_action "CPU" "$CPU"
        (( $(echo "$MEM > $MEM_THRESHOLD" | bc -l) )) && take_action "MEMORY" "$MEM"
        (( DISK > DISK_THRESHOLD )) && take_action "DISK" "$DISK"
        
        sleep "$INTERVAL"
    done
}
```

**Improvements:**
- âœ… **Startup logging** (PID tracking)
- âœ… **User feedback** (where to check logs)
- âœ… **Top process tracking** (identifies culprits)
- âœ… **Enhanced CSV** (more data points)
- âœ… **Consistent date format**

---

### 12. **Help System** (NEW ONLY)

#### OLD Version
```bash
*)
    echo "Usage: $0 {daemon|dashboard}"
    ;;
```

**Limitation:**
- Minimal help
- No documentation
- No examples

---

#### NEW Version
```bash
show_help() {
    cat << EOF
Usage: $0 {daemon|dashboard} [OPTIONS]

MODES:
  daemon       Run as background daemon
  dashboard    Display real-time dashboard
  help         Show this help message

EXAMPLES:
  $0 dashboard              # Interactive dashboard
  $0 daemon                 # Run daemon in background
  $0 daemon &               # Run daemon as background process

CONFIGURATION:
  Edit $CONFIG_FILE to customize:
    - CPU_THRESHOLD (default: 80)
    - MEM_THRESHOLD (default: 85)
    - DISK_THRESHOLD (default: 90)
    - AUTO_KILL_ENABLED (default: false)
    - PROTECTED_PROCESSES (e.g., "systemd init sshd")

FILES:
  $LOG_FILE      - Alert and action logs
  $CSV_FILE      - Historical metrics
  $CONFIG_FILE   - Configuration

SAFETY:
  Set AUTO_KILL_ENABLED=false in config for manual intervention only.
  Set AUTO_KILL_ENABLED=true to enable automated process killing.
  Add critical processes to PROTECTED_PROCESSES list.

EOF
}

case "$1" in
    daemon)
        daemon
        ;;
    dashboard)
        dashboard
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Error: Invalid mode '$1'"
        echo ""
        show_help
        exit 1
        ;;
esac
```

**Features:**
- âœ… Comprehensive help text
- âœ… Usage examples
- âœ… Configuration guidance
- âœ… Safety warnings
- âœ… File descriptions
- âœ… Multiple help triggers

---

## ğŸš¨ Critical Safety Comparison

### Dangerous Scenarios

| Scenario | OLD Version Behavior | NEW Version Behavior |
|----------|---------------------|---------------------|
| **SSH spike to 81%** | âŒ Kills sshd instantly â†’ Locked out | âœ… Protected, skipped |
| **Database checkpoint** | âŒ Kills postgres â†’ Data corruption | âœ… Protected, skipped |
| **Restarting service** | âŒ Kill loop (kills every 5s) | âœ… 60s cooldown, stops loop |
| **False positive** | âŒ Kills on warning threshold (80%) | âœ… Only kills at 95%+ |
| **User mistake** | âŒ No way to disable killing | âœ… AUTO_KILL_ENABLED=false |
| **Process cleanup** | âŒ SIGKILL only, dirty shutdown | âœ… SIGTERM first, clean exit |

---

## ğŸ“Š Feature Matrix

| Feature | Old | New | Benefit |
|---------|-----|-----|---------|
| **Environment variables** | âŒ | âœ… | Flexible deployment |
| **Config file validation** | âŒ | âœ… | No crashes |
| **Fallback defaults** | âŒ | âœ… | Works without config |
| **Color-coded UI** | âŒ | âœ… | Better UX |
| **Progress bars** | âŒ | âœ… | Visual clarity |
| **Unicode graphics** | âŒ | âœ… | Professional look |
| **Protected processes** | âŒ | âœ… | System safety |
| **Kill cooldown** | âŒ | âœ… | Prevents loops |
| **Graceful shutdown** | âŒ | âœ… | Data integrity |
| **Dual thresholds** | âŒ | âœ… | Better control |
| **Auto-kill toggle** | âŒ | âœ… | User choice |
| **Process verification** | âŒ | âœ… | Fewer errors |
| **Detailed logging** | âŒ | âœ… | Better debugging |
| **Log levels** | âŒ | âœ… | Structured logs |
| **Top process tracking** | âŒ | âœ… | Better analysis |
| **User column** | âŒ | âœ… | Security audit |
| **Network auto-detect** | âŒ | âœ… | Universal compat |
| **Error handling** | âŒ | âœ… | Graceful failures |
| **Comprehensive help** | âŒ | âœ… | User-friendly |
| **Status summary** | âŒ | âœ… | Quick overview |

---

## ğŸ¯ Key Takeaways

### What You Learned by Comparing

1. **Error Handling Matters**
   - Old: Assumes everything works
   - New: Checks, validates, falls back

2. **User Safety is Critical**
   - Old: Destructive by default
   - New: Safe by default, opt-in danger

3. **User Experience**
   - Old: Functional but basic
   - New: Professional and intuitive

4. **Maintainability**
   - Old: Hard to debug, minimal logging
   - New: Comprehensive logs, clear structure

5. **Production Readiness**
   - Old: Demo/toy project
   - New: Production-grade tool

---

## ğŸ’¡ Best Practices Demonstrated

### From OLD to NEW

| Old Approach | Problem | New Solution |
|--------------|---------|--------------|
| Hardcoded paths | No flexibility | Environment variables |
| No error checks | Silent failures | Explicit validation |
| Immediate kills | Data loss | Graceful shutdown |
| No protection | System damage | Protected process list |
| Single threshold | Binary action | Graduated response |
| Plain output | Hard to read | Color-coded visual |
| Minimal logs | Can't debug | Structured logging |
| Assumes working | Breaks easily | Defensive coding |

---

## ğŸ”„ Migration Guide

If you have the old version running:

1. **Backup your data**:
   ```bash
   cp monitor.log monitor.log.backup
   cp system_metrics.csv system_metrics.csv.backup
   ```

2. **Stop old daemon**:
   ```bash
   pkill -f "system_monitor.sh daemon"
   ```

3. **Update configuration**:
   ```bash
   # Add new settings to monitor_config.conf
   echo "AUTO_KILL_ENABLED=false" >> monitor_config.conf
   echo "CPU_KILL_THRESHOLD=95" >> monitor_config.conf
   echo "MEM_KILL_THRESHOLD=95" >> monitor_config.conf
   echo 'PROTECTED_PROCESSES="systemd init bash sshd"' >> monitor_config.conf
   ```

4. **Replace script**:
   ```bash
   cp system_monitor_new.sh system_monitor.sh
   chmod +x system_monitor.sh
   ```

5. **Test in dashboard mode first**:
   ```bash
   ./system_monitor.sh dashboard
   ```

6. **Deploy daemon when confident**:
   ```bash
   ./system_monitor.sh daemon &
   ```

---

## âœ… Summary

The new version is a **complete rewrite** that transforms a basic monitoring script into a **production-ready system tool** with:

- **6x more code** but **infinitely safer**
- **Professional UI** instead of plain text
- **Intelligent safety** instead of blind automation
- **Defensive programming** instead of assumptions
- **User-friendly** instead of developer-only

**Bottom Line**: The old version was a proof-of-concept. The new version is something you can actually deploy on production servers.

---

**Recommendation**: Use the NEW version. The OLD version is dangerous in automated mode.